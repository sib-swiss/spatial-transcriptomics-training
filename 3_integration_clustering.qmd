---
title: "Integration and clustering"
engine: knitr
---


```{r}
#| output: false
library(Seurat)
library(ggplot2)
library(clustree)
library(patchwork)
library(dplyr)
```

```{r}
seu_list <- readRDS("output/normalized.rds")
seu <- merge(seu_list[[1]], seu_list[[2]])
```

```{r}
#| output: false
VariableFeatures(seu) <- intersect(VariableFeatures(seu_list$Anterior),
                           VariableFeatures(seu_list$Posterior))
seu <- RunPCA(seu, assay = "SCT", npcs = 50, verbose = FALSE)
seu <- RunUMAP(seu, reduction = "pca", dims = 1:50)
```

```{r}
DimPlot(seu, reduction = "pca", group.by = "orig.ident") + 
  scale_color_viridis_d(option = "cividis")
DimPlot(seu, reduction = "umap", group.by = "orig.ident") + 
  scale_color_viridis_d(option = "cividis")
```

## Integration

You can safely ignore the warning: `Warning: Different cells and/or features from existing assay SCT`. See [this issue](https://github.com/satijalab/seurat/issues/7145). 

```{r}
#| output: false

features <- SelectIntegrationFeatures(seu_list)
seu_list <- PrepSCTIntegration(seu_list, anchor.features = features)

anchors <- FindIntegrationAnchors(
  seu_list,
  normalization.method = "SCT",
  anchor.features = features
)
seu_int <- IntegrateData(anchors, normalization.method = "SCT")
```

```{r}
#| warning: false
seu_int <- FindVariableFeatures(seu_int)
seu_int <- RunPCA(seu_int, npcs = 50, verbose = FALSE)
seu_int <- RunUMAP(seu_int, reduction = "pca", dims = 1:50)
DimPlot(seu_int, reduction = "umap") + 
  scale_color_viridis_d(option = "cividis")
```




## Identifying clusters

Seurat implements a graph-based clustering approach. Distances between the spots are calculated based on
previously identified PCs. Briefly, Seurat identifies clusters of spots by a shared nearest neighbor (SNN)
modularity optimization based clustering algorithm. First, it identifies k-nearest neighbors (KNN) and constructs
the SNN graph. Then it optimizes the modularity function to determine clusters. For a full description of the
algorithms, see Waltman and van Eck (2013) The European Physical Journal B.

The FindClusters function implements the procedure, and contains a resolution parameter that sets the granularity
of the downstream clustering, with increased values leading to a greater number of clusters.

```{r}
resolution_vector <- seq(0.1,1,0.1)
seu_int <- FindNeighbors(seu_int, reduction = "pca", dims = 1:50)
seu_int <- FindClusters(object = seu_int,
                          resolution = resolution_vector,
                          verbose=FALSE)
```

```{r}
clustree(seu_int, prefix = "integrated_snn_res.")
```

```{r}
#| warning: false
res <- "integrated_snn_res.0.4"
nclust <- seu_int[[res]] |> unique() |> nrow()
cluster_cols <- viridis::viridis_pal(option = "H")(nclust)

DimPlot(seu_int,
        group.by = res,
        shuffle = TRUE,
        cols = cluster_cols)

SpatialPlot(seu_int, group.by = res, pt.size.factor = 2) + 
  plot_layout(guides='collect') &
  theme(legend.position = "none") &
  scale_fill_viridis_d(option = "H")
```

```{r}
Idents(seu_int) <- "integrated_snn_res.0.4"
```

```{r}
#| warning: false
DefaultAssay(seu_int) <- "SCT"
seu_int <- PrepSCTFindMarkers(seu_int)
all_marks <- FindAllMarkers(seu_int, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
```



```{r}
#| fig-width: 9
top_markers <- all_marks |>
  mutate(order_value = avg_log2FC * -log10(p_val_adj + 1e-323)) |>
  arrange(cluster, desc(order_value)) |>
  group_by(cluster) |>
  top_n(3)

# DefaultAssay(seu_int) <- "integrated"

DotPlot(seu_int, features = top_markers$gene) +
  scale_x_discrete(guide = guide_axis(angle = 45))
```

```{r}
SpatialDimPlot(seu_int, 
               cells.highlight = CellsByIdentities(object = seu_int,
                                                   idents = 3)) + 
  plot_layout(guides='collect') &
  theme(legend.position = "none") 

SpatialPlot(seu_int,
            features = top_markers$gene[top_markers$cluster == 3][1],
            pt.size.factor = 2) 
```


```{r}
SpatialDimPlot(seu_int, 
               cells.highlight = CellsByIdentities(object = seu_int,
                                                   idents = 0)) + 
  plot_layout(guides='collect') &
  theme(legend.position = "none") 

SpatialPlot(seu_int,
            features = top_markers$gene[top_markers$cluster == 0][1],
            pt.size.factor = 2) 
```


<!-- ```{r} -->
<!-- DefaultAssay(seu_list$Anterior) <- "SCT" -->

<!-- seu_list$Anterior <- -->
<!--   FindSpatiallyVariableFeatures( -->
<!--     seu_list$Anterior, -->
<!--     features = rownames(seu_int), -->
<!--     selection.method = "moransi" -->
<!--   ) -->

<!-- spatialFeatures <- -->
<!--   SVFInfo(seu_list$Anterior, method = "moransi", status = TRUE) -->
<!-- spatialFeatures <- -->
<!--   spatialFeatures |> arrange(rank) -->

<!-- SpatialPlot(seu_list$Anterior, features = rownames(spatialFeatures)[1:6], ncol = 3, alpha = c(0.1, 1)) -->
<!-- ``` -->

