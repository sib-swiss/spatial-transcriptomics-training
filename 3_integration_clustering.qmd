---
title: "Integration and clustering"
engine: knitr
---


```{r}
#| output: false
library(Seurat)
library(ggplot2)
library(clustree)
library(patchwork)
```

```{r}
seu_list <- readRDS("output/normalized.rds")
seu <- merge(seu_list[[1]], seu_list[[2]])
```

```{r}
VariableFeatures(seu) <- intersect(VariableFeatures(seu_list$Anterior),
                           VariableFeatures(seu_list$Posterior))
seu <- RunPCA(seu, assay = "SCT", npcs = 50, verbose = FALSE)
seu <- RunUMAP(seu, reduction = "pca", dims = 1:50)
```

```{r}
DimPlot(seu, reduction = "pca", group.by = "orig.ident") + 
  scale_color_viridis_d(option = "cividis")
DimPlot(seu, reduction = "umap", group.by = "orig.ident") + 
  scale_color_viridis_d(option = "cividis")
```

## Integration

```{r}


features <- SelectIntegrationFeatures(seu_list)
seu_list <- PrepSCTIntegration(seu_list, anchor.features = features)

anchors <- FindIntegrationAnchors(
  seu_list,
  normalization.method = "SCT",
  anchor.features = features
)
seu_int <- IntegrateData(anchors, normalization.method = "SCT")
```

```{r}
seu_int <- FindVariableFeatures(seu_int)
seu_int <- RunPCA(seu_int, npcs = 50, verbose = FALSE)
seu_int <- RunUMAP(seu_int, reduction = "pca", dims = 1:50)
DimPlot(seu_int, reduction = "umap")
```




## Identifying clusters

Seurat implements a graph-based clustering approach. Distances between the spots are calculated based on
previously identified PCs. Briefly, Seurat identifies clusters of spots by a shared nearest neighbor (SNN)
modularity optimization based clustering algorithm. First, it identifies k-nearest neighbors (KNN) and constructs
the SNN graph. Then it optimizes the modularity function to determine clusters. For a full description of the
algorithms, see Waltman and van Eck (2013) The European Physical Journal B.

The FindClusters function implements the procedure, and contains a resolution parameter that sets the granularity
of the downstream clustering, with increased values leading to a greater number of clusters.

```{r}
resolution_vector <- seq(0.1,1,0.1)
seu_int <- FindNeighbors(seu_int, reduction = "pca", dims = 1:50)
seu_int <- FindClusters(object = seu_int,
                          resolution = resolution_vector,
                          verbose=FALSE)
```

```{r}
clustree(seu_int, prefix = "integrated_snn_res.")
```

```{r}

res <- "integrated_snn_res.0.4"
nclust <- seu_int[[res]] |> unique() |> nrow()
cluster_cols <- viridis::viridis_pal(option = "H")(nclust)

DimPlot(seu_int,
        group.by = res,
        shuffle = TRUE,
        cols = cluster_cols)

SpatialPlot(seu_int, group.by = res) + 
  plot_layout(guides='collect') &
  theme(legend.position = "none") &
  scale_fill_viridis_d(option = "H")
```

```{r}
Idents(seu_int) <- "integrated_snn_res.0.4"

SpatialDimPlot(seu_int, 
               alpha = 0.6,
               cells.highlight = CellsByIdentities(object = seu_int,
                                                   idents = 7)) + 
  plot_layout(guides='collect') &
  theme(legend.position = "none") 

SpatialDimPlot(seu_int, 
               alpha = 0.6,
               cells.highlight = CellsByIdentities(object = seu_int,
                                                   idents = 0)) + 
  plot_layout(guides='collect') &
  theme(legend.position = "none") 
```

```{r}
seu_int <- PrepSCTFindMarkers(seu_int)
all_marks <- FindAllMarkers(seu_int, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)
```

```{r}
SpatialPlot(seu_int, features = "Fth1") 
# oligodendrocytes, myenilated neurons
```



```{r}
DefaultAssay(seu_list$Anterior) <- "SCT"

seu_list$Anterior <-
  FindSpatiallyVariableFeatures(
    seu_list$Anterior,
    features = rownames(seu_int),
    selection.method = "moransi"
  )

sf <- SpatiallyVariableFeatures(seu_list$Anterior)

spatialFeatures <-
  SVFInfo(seu_list$Anterior, method = "moransi", status = TRUE)
spatialFeatures <-
  spatialFeatures |> arrange(rank)

SpatialPlot(seu_list$Anterior, features = rownames(spatialFeatures)[1:6], ncol = 3, alpha = c(0.1, 1))
```

