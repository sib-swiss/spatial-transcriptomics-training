{
  "hash": "06accf6148969c0443a56681bf049205",
  "result": {
    "markdown": "---\ntitle: \"Quality control\"\nengine: knitr\n---\n\n\n## Material\n\n\n{{< downloadthis assets/pdf/02_introduction_ST.pdf dname=\"02_introduction_ST\" label=\"Download the presentation\" icon=\"filetype-pdf\" >}}\n\n\n\n## Introduction\n\nIn this tutorial we are working with two mouse brain slices, the anterior and posterior. The two brain sections represent the sagittal (longitudinal) plane of the mouse brain:  \n\n![Mouse brain sagittal](assets/images/mouse_brain_sagittal.png)\n\nYou can find an interactive map with all brain regions at the [Allen Brain Atlas](http://atlas.brain-map.org/atlas?atlas=2&plate=100883804#atlas=2&plate=100884129&resolution=19.04&x=7671.818403764205&y=4000&zoom=-4&structure=549)\n\nOur slices contain the anterior and posterior sides of the sagittal section of the mouse brain:\n\n::: {layout-ncol=2}\n![Anterior](raw_data/Anterior/spatial/tissue_lowres_image.png)\n\n![Posterior](raw_data/Posterior/spatial/tissue_lowres_image.png)\n:::\n\n## Quality reports\n\nIn the `course_data` directories you can find an html report named `web_summary.html` that gives information about the spaceranger run. \n\n\n::: {.callout-important}\n## Exercise\n\nHave a look at both reports. Could we capture the entire slice? Can you expect all spots have reads? How many informative spots do we have for both slices? \n::: \n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\n- For both the Anterior and Posterior parts of the slice are outside the captured region\n- Also not all spots are on a slice, the number of spots per slice:\n  - Anterior: 2695\n  - Posterior: 3355\n::: \n\n## Loading the data into Seurat\n\nWe first load the required packages, among which `Seurat`:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-1_11b560a8e330fdbb37b7e229b8336ef6'}\n\n```{.r .cell-code}\nlibrary(Seurat)\nlibrary(tidyr)\nlibrary(patchwork)\nlibrary(ggplot2)\n```\n:::\n\n\nThen we, load the data into two Seurat objects. Here, we loop over the two slices, and combine it in a list of two seurat objects. \n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-2_864cacafc4506a5016607ba5d1b4bac4'}\n\n```{.r .cell-code}\nseu_list <- lapply(c(\"Anterior\", \"Posterior\"), function(slice) {\n  # load the invidual slices\n  seu <- Load10X_Spatial(data.dir = file.path(\"course_data\", slice),\n                  slice = slice)\n  # set the identity of the spots to the slice identifier\n  seu$orig.ident <- slice\n  return(seu)\n})\n```\n:::\n\n\nAfter creating the list, we merge the two objects into one Seurat object, and we set the default identity (mostly for plotting purposes) to the slice identifier (i.e. Posterior or Anterior).\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-3_f73e37e99ba933b5f4a82451b5f745f7'}\n\n```{.r .cell-code}\nseu <- merge(seu_list[[1]], seu_list[[2]])\n```\n:::\n\n\n### The `Seurat` object\n\nThe `seu` object we have created has the class `Seurat`. The object contains multi-level slots and lists. Each `Seurat` object contains exactly the same slots that are specified in the image below (get slot descriptions by typing `?SeuratObject::Seurat`). You can get the information inside a slot with `@`, in the same way as you would use the `$` for lists (e.g. `seu@meta.data` will return the a data frame with information on each cell). Slots can be filled with other R objects, like lists, vectors, data frames or any other class. Here's an overview of all slots that are in a `Seurat` object:\n\n![](assets/images/seurat_object.png)\n\nIn addition to the original count table and image, the `Seurat` object can therefore store a lot of information that is generated during your analysis, like results of a normalization (`@assays$RNA@data`) a PCA or UMAP (`@reductions`) and the clustering (`@graphs`). It also tracks all the commands that have been used to generate the object in its current state (`@commands`). Therefore, while going through the analysis steps, the same object gets more and more of its slots filled. Because most `Seurat` functions return the input object + adjusted slots, we can use this syntax:\n\n```\nseurat_object <- Seurat::function(seurat_object)\n```\n\nSo, the function takes an object as input and we assign it to an object with the same name. Meaning that we overwrite the object used as input. This is fine in many cases, because `Seurat` adds information to the input object, and returns is. \n\nBecause we want to set the default identity of each spot to the slice name (i.e. 'anterior' or 'posterior'), we change the slot `active.ident` with the function `SetIdent`:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-4_d1c08deb0f379c3eb6f2bc32d45646fb'}\n\n```{.r .cell-code}\nseu <- SetIdent(seu, value = \"orig.ident\")\n```\n:::\n\n\n\nIn order to check out the count data that is stored in our Seurat object, we can run `GetAssayData`, in which we specify the assay and the layer from which we extract the counts. Since we have a combined object we have two layers with counts, `counts.1` corresponding to `Anterior` and `counts.2` corresponding to `Posterior`. Let's have a look at the counts from the Anterior slice:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-5_d69de5e2816cfa9ee0835f7fe1b2bf62'}\n\n```{.r .cell-code}\ncounts <- GetAssayData(seu, assay = \"Spatial\", layer = \"counts.1\")\ncounts[1:10,1:10]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n  [[ suppressing 10 column names 'AAACAAGTATCTCCCA-1_1', 'AAACACCAATAACTGC-1_1', 'AAACAGAGCGACTCCT-1_1' ... ]]\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n                           \nXkr4    . . . . . . . . . .\nGm1992  . . . . . . . . . .\nGm19938 . . . . . . . . . .\nGm37381 . . . . . . . . . .\nRp1     . . . . . . . . . .\nSox17   . 1 . . . 2 . . 1 .\nGm37587 . . . . . . . . . .\nGm37323 . . . . . . . . . .\nMrpl15  2 1 4 . 2 1 2 3 . 6\nLypla1  . 1 2 2 . . 1 3 1 3\n```\n:::\n:::\n\n\n::: {.callout-important}\n## Exercise\n\nExtract the matrix with counts belonging the posterior slice and get the median counts per spot by using the function `colSums` and `median` on the matrix. Does this correspond with the report? \n::: \n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nWe can get the median counts like this:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-6_a6012f9dac95b78f817ffd07284c2227'}\n\n```{.r .cell-code}\ncounts <- GetAssayData(seu, assay = \"Spatial\", layer = \"counts.2\")\nmedian_counts <- colSums(counts) |> median()\nmedian_counts\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 15783\n```\n:::\n:::\n\n\nNote that the median counts we have over here, correspond to 'Median UMI Counts per Spot' in the report (so not 'Mean Reads per Spot'). Indeed the also the report shows a median of 15738. \n\n::: \n\nThe original H&E slice are also part of the Seurat object, and we can visualize those:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-7_4878690bc757978ae229462226563425'}\n\n```{.r .cell-code}\nSpatialPlot(seu, alpha = 0) + \n  plot_layout(guides='collect') & theme(legend.position = \"none\")\n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nAnd we can plot any feature as an overlay, for example, here we have the number of UMI per spot: \n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-8_d3ad3931c421c570aae170c01610ca96'}\n\n```{.r .cell-code}\nSpatialPlot(seu, features = \"nCount_Spatial\", pt.size.factor = 2.5) + \n  plot_layout(guides='collect') & theme(legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\n## Quality control\n\nWe can assess the quality of our data at the level of the spots (i.e. the columns in the count matrix) and the genes (the rows). Typically, most quality assessment is done on the level of the spots. Data per spot is stored in the `@meta.data` slot. This is a `data.frame` where the rows correspond to the spots, and each column contains data per spot. By loading the data as `Seurat` object, we have already pre-filled a few meta data columns\n\n::: {.callout-important}\n## Exercise\n\nCheck out the metadata dataframe by running `seu@meta.data`. Which columns are already there, and what do they probably mean? \n::: \n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-9_6df4de2e7d11079377b8013a85256d06'}\n\n```{.r .cell-code}\nseu@meta.data |> head()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     orig.ident nCount_Spatial nFeature_Spatial\nAAACAAGTATCTCCCA-1_1   Anterior          13991             4462\nAAACACCAATAACTGC-1_1   Anterior          39797             8126\nAAACAGAGCGACTCCT-1_1   Anterior          29951             6526\nAAACAGCTTTCAGAAG-1_1   Anterior          42333             8190\nAAACAGGGTCTATATT-1_1   Anterior          35700             8090\nAAACATGGTGAGAGGA-1_1   Anterior          22148             6518\n```\n:::\n:::\n\n\nHere, we have the following information:\n\n- rownames: spot barcode (= identifier)\n- `orig.ident`: the slice identifier\n- `nCount_Spatial`: the total number of UMI for each spot\n- `nFeature_Spatial`: the total number of detected genes per spot\n\n::: \n\n### Library size versus detected genes\n\nWe can use these columns to plot spot metadata. Everytime there is a function in `Seurat` that contains an option `feature` we can fill it out, like in `FeatureScatter`, that we can use to plot the number of genes versus the number of UMI. \n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-10_92ae4737a29fe008ce2105fd8ceb46d9'}\n\n```{.r .cell-code}\nFeatureScatter(seu,\n               feature1 = \"nCount_Spatial\",\n               feature2 = \"nFeature_Spatial\",\n               shuffle = TRUE\n) + scale_color_viridis_d(option = \"cividis\")\n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n### Percent of mitochondrial UMI\n\nA high percentage of mitochondrial UMI can point to low quality spots, because damaged cells typically leak out cytoplasmic mRNA, while the mitochondria stay inside. We can calculate the percentage of mitochondria like this:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-11_4165d5781f494a07ce58025b32e15461'}\n\n```{.r .cell-code}\nseu <- PercentageFeatureSet(seu,\n                             pattern = \"^MT-|^Mt-|^mt-\",\n                             col.name = \"percent_mt\"\n)\n```\n:::\n\n\n::: {.callout-important}\n## Exercise\n\nThe percentage of mitochondrial UMI is stored in the `@meta.data` slot. What is the name of the column? \n\nPlot the percentage of mitochondrial UMI versus the number of UMI per spot with `FeatureScatter`. \n::: \n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nA column names `percent_mt` appeared. \n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-12_ae6915055bdabc030d33d5b79749e2fe'}\n\n```{.r .cell-code}\nhead(seu@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                     orig.ident nCount_Spatial nFeature_Spatial percent_mt\nAAACAAGTATCTCCCA-1_1   Anterior          13991             4462  10.871274\nAAACACCAATAACTGC-1_1   Anterior          39797             8126   9.993216\nAAACAGAGCGACTCCT-1_1   Anterior          29951             6526  14.239925\nAAACAGCTTTCAGAAG-1_1   Anterior          42333             8190   6.779581\nAAACAGGGTCTATATT-1_1   Anterior          35700             8090   5.128852\nAAACATGGTGAGAGGA-1_1   Anterior          22148             6518  10.791042\n```\n:::\n:::\n\n\nWe can create the scatterplot like this:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-13_3911cdebef8dae7e622221a2fc353ebd'}\n\n```{.r .cell-code}\nFeatureScatter(seu,\n               feature1 = \"nCount_Spatial\",\n               feature2 = \"percent_mt\",\n               shuffle = TRUE\n) + scale_color_viridis_d(option = \"cividis\")\n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n::: \n\nNow we have to decide whether we want to filter away spots with high mitochondrial counts, and if so, at what threshold. In order to make a decision, it makes sense to plot the mitochondrial counts in a spatial context, so we can check whether it correpsonds to spatial features: \n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-14_57ed6941d4e9ff88ecf922c3db7f3cd5'}\n\n```{.r .cell-code}\nSpatialPlot(seu, features = \"percent_mt\", pt.size.factor = 2.5) + \n  plot_layout(guides='collect') & theme(legend.position = \"right\")\n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nWe can see that a high percentage of mitochondrial counts correspond with the hippocampus, and the sides of the out areas of the cortex. In the posterior slice, there is a clear spatial context and there is no clear indication for spots being damaged, we will not filter out spots based on mitochondrial UMI. However, in the Anterior slice, we see a spot outside the main area (just above the olfactory bulb) that seems to have ended up there because of debris.\n\n## Filtering\n\n### Identifying low-quality spots\n\n\nWe decide to filter out the spot that is high in UMI counts in the Anterior slice and in addition, we will filter spots that have fewer than 500 genes expressed. In order to visualize the spots we create two more columns in the `@meta.data` slot that represent which cell are filtered out. \ns\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-15_be3df86b16cd8edeac1e97dc8e97b6a6'}\n\n```{.r .cell-code}\n# defining the high mt spot in anterior\nseu$percent_mt_keep <- !(seu$orig.ident == \"Anterior\" & seu$percent_mt > 38)\n\ncells_mt_keep <- colnames(seu)[seu$percent_mt_keep]\n\nSpatialPlot(seu, cells.highlight = cells_mt_keep,\n            cols.highlight = c(\"grey50\", \"red\"),\n            pt.size.factor = 2.5) +\n  plot_annotation(title = \"Filter % mitochondrial UMI\") +\n  plot_layout(guides='collect') & theme(legend.position = \"none\") \n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# defining the low number of genes\nseu$nFeature_Spatial_keep <- seu$nFeature_Spatial > 100\n\ncells_nfeature_keep <- colnames(seu)[seu$nFeature_Spatial_keep]\n\nSpatialPlot(seu, cells.highlight = cells_nfeature_keep,\n            cols.highlight = c(\"grey50\", \"red\"),\n            pt.size.factor = 2.5) +\n  plot_annotation(title = \"Filter % low number of features\") +\n  plot_layout(guides='collect') & theme(legend.position = \"none\") \n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\nNow, we remove the spots, and visualize the spots that are left over:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-16_993de5fb8e72b6695afc362e79fd36a7'}\n\n```{.r .cell-code}\nseu <- seu[, seu$percent_mt_keep & seu$nFeature_Spatial_keep]\n\nSpatialPlot(seu, group.by = \"percent_mt_keep\", pt.size.factor = 2.5)  +\n  plot_layout(guides='collect') & theme(legend.position = \"none\") & \n  scale_fill_manual(values = c(\"black\"))\n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n### Gene-level QC\n\nSome genes can be expressed in very high percentages and therefore have a large effect on the normalization. In order to see whether there are genes that are very high expressed we can plot them by percentage of the total counts per spot:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-17_d4176fab688cd6a6b4d283cd2ecd8594'}\n\n```{.r .cell-code}\nmost_expressed_boxplot <- function(raw_counts) {\n  raw_counts@x <-\n    raw_counts@x / rep.int(colSums(raw_counts), diff(raw_counts@p)) * 100\n  most_expressed <-\n    order(Matrix::rowSums(raw_counts), decreasing = TRUE)[30:1]\n  \n  raw_counts[most_expressed,] |>\n    as.matrix() |>\n    t() |>\n    boxplot(\n      cex.axis = 0.5,\n      cex.lab = 0.8,\n      cex = 0.1,\n      las = 1,\n      xlab = \"% total count per spot\",\n      col = (scales::hue_pal())(30)[30:1],\n      horizontal = TRUE\n    )\n}\n\n\nmost_expressed_boxplot(seu[[\"Spatial\"]]$counts.1)\n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\nmost_expressed_boxplot(seu[[\"Spatial\"]]$counts.2)\n```\n\n::: {.cell-output-display}\n![](2_quality_control_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n:::\n\n\nAs we don't see very high expression percentages, and it happens for expected genes (e.g. Bc1), we decide to keep all genes in the analysis. \n\nAfter quality control, we can save the output as an rds files:\n\n\n::: {.cell hash='2_quality_control_cache/html/unnamed-chunk-18_05c4c0ccbafb10ed41d931ab5c643ef4'}\n\n```{.r .cell-code}\noutput_folder <- \"output\"\ndir.create(output_folder, showWarnings = FALSE)\n\nsaveRDS(seu,\n        paste0(\"output/seu_part2.rds\"))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}