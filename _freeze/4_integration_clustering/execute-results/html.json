{
  "hash": "a4889b0b275f86163d528c4563a91144",
  "result": {
    "markdown": "---\ntitle: \"Integration and clustering\"\nengine: knitr\n---\n\n\n## Material\n\n\n{{< downloadthis assets/pdf/03_analysis_ST.pdf dname=\"03_analysis_ST\" label=\"Download the presentation\" icon=\"filetype-pdf\" >}}\n\n\n\n## Dimensionality reduction\n\nWe load the required packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Seurat)\nlibrary(ggplot2)\nlibrary(clustree)\nlibrary(patchwork)\nlibrary(dplyr)\n```\n:::\n\n\nAnd we load the list created after normalization and scaling, followed by a merge:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu_list <- readRDS(\"output/seu_part3.rds\")\nseu <- merge(seu_list[[1]], seu_list[[2]])\n```\n:::\n\n\n\nIn order to perform dimensionality reduction, we first need to select variable features of both slices. To get a good representation of both slices, we take the intersect (i.e. genes that are variable in both slices):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nVariableFeatures(seu) <- intersect(VariableFeatures(seu_list$Anterior),\n                           VariableFeatures(seu_list$Posterior))\n```\n:::\n\n\n::: {.callout-important}\n## Exercise\n\nHow many variable features do we have? Why did we select fewer genes than the default (check `?VariableFeatures`)?\n\n::: \n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nJust by typing the object name we already see the number of variable features: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n83447 features across 6039 samples within 3 assays \nActive assay: SCT (18877 features, 1938 variable features)\n 3 layers present: counts, data, scale.data\n 2 other assays present: Spatial, RNA\n 2 images present: Anterior, Posterior\n```\n:::\n:::\n\n\nSo, we have 1938 variable features. Because we selected the features that are variable in both slices, it is fewer genes than the originally selected default. \n\n:::\n\nNow that we have selected the most variable features, we can generate a PCA based on the normalized and scaled data of those:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu <- RunPCA(seu, assay = \"SCT\", npcs = 50, verbose = FALSE)\n\nDimPlot(seu, reduction = \"pca\", group.by = \"orig.ident\") + \n  scale_color_viridis_d(option = \"cividis\")\n```\n\n::: {.cell-output-display}\n![](4_integration_clustering_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nBased on the PCA, we can create a UMAP to get a representation of all 50 dimensions in a two dimensional space:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu <- RunUMAP(seu, reduction = \"pca\", dims = 1:50)\n\nDimPlot(seu, reduction = \"umap\", group.by = \"orig.ident\") + \n  scale_color_viridis_d(option = \"cividis\")\n```\n\n::: {.cell-output-display}\n![](4_integration_clustering_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-important}\n## Exercise\n\nThe two slices come from one brain, the posterior and anterior sides. Do you expect spots from similar cells/tissue in both slices? Is that represented in the UMAP? \n\n::: \n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nYes, it is likely that there are similar spots in both slides, but the spots of both slices hardly overlap in the UMAP. Therefore, it makes sense to do an integration. \n\n:::\n\n## Integration\n\nTo integrate the two slices, we first need to select integration features. These are genes that are variable in both slices. We then prepare the data for integration, find the integration anchors (i.e. spots that are within each others neigbourhoods), and integrate the data:\n\n::: {.callout-note}\nYou can safely ignore the warning: `Warning: Different cells and/or features from existing assay SCT`. See [this issue](https://github.com/satijalab/seurat/issues/7145). \n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfeatures <- SelectIntegrationFeatures(seu_list)\nseu_list <- PrepSCTIntegration(seu_list, anchor.features = features)\n\nanchors <- FindIntegrationAnchors(\n  seu_list,\n  normalization.method = \"SCT\",\n  anchor.features = features\n)\nseu <- IntegrateData(anchors, normalization.method = \"SCT\")\n```\n:::\n\n\n::: {.callout-important}\n## Exercise\n\nHow is the integrated data stored in the seurat object? \n\nHint: type `seu` to get an idea. \n\n::: \n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAn object of class Seurat \n85447 features across 6039 samples within 4 assays \nActive assay: integrated (2000 features, 2000 variable features)\n 2 layers present: data, scale.data\n 3 other assays present: Spatial, RNA, SCT\n 2 images present: Anterior, Posterior\n```\n:::\n:::\n\n\nWe see that our object now has four assays, `integrated` (active), `Spatial`, `RNA` and `SCT`. The integrated data is stored in the `integrated` assay. We use this assay only for dimensionality reduction and clustering. When we go to marker gene identification, we use `SCT` again. \n\n:::\n\nBecause we re-do the dimensionality reduction, we also again extract the variable features, run the PCA and the UMAP:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseu <- FindVariableFeatures(seu)\nseu <- RunPCA(seu, npcs = 50, verbose = FALSE)\nseu <- RunUMAP(seu, reduction = \"pca\", dims = 1:50)\nDimPlot(seu, reduction = \"umap\") + \n  scale_color_viridis_d(option = \"cividis\")\n```\n\n::: {.cell-output-display}\n![](4_integration_clustering_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n## Identifying clusters\n\nSeurat implements a graph-based clustering approach. Distances between the spots are calculated based on previously identified PCs. Briefly, Seurat identifies clusters of spots by a shared nearest neighbor (SNN) modularity optimization based clustering algorithm. First, it identifies k-nearest neighbors (KNN) and constructs the SNN graph. Then it optimizes the modularity function to determine clusters. For a full description of the algorithms, see Waltman and van Eck (2013) The European Physical Journal B.\n\nThe FindClusters function implements the procedure, and contains a resolution parameter that sets the granularity of the downstream clustering, with increased values leading to a greater number of clusters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresolution_vector <- seq(0.1,1,0.1)\nseu <- FindNeighbors(seu, reduction = \"pca\", dims = 1:50)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nComputing nearest neighbor graph\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nComputing SNN\n```\n:::\n\n```{.r .cell-code}\nseu <- FindClusters(object = seu,\n                          resolution = resolution_vector,\n                          verbose=FALSE)\n```\n:::\n\n\nSome new columns appeared in the metadata data frame after the clustering, each representing the cluster ID per spot for a given resolution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(seu@meta.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"orig.ident\"             \"nCount_Spatial\"         \"nFeature_Spatial\"      \n [4] \"percent_mt\"             \"percent_mt_keep\"        \"nFeature_Spatial_keep\" \n [7] \"nCount_SCT\"             \"nFeature_SCT\"           \"integrated_snn_res.0.1\"\n[10] \"integrated_snn_res.0.2\" \"integrated_snn_res.0.3\" \"integrated_snn_res.0.4\"\n[13] \"integrated_snn_res.0.5\" \"integrated_snn_res.0.6\" \"integrated_snn_res.0.7\"\n[16] \"integrated_snn_res.0.8\" \"integrated_snn_res.0.9\" \"integrated_snn_res.1\"  \n[19] \"seurat_clusters\"       \n```\n:::\n:::\n\n\nTo get an overview of the clustering over the different resolutions, we can use `clustree` to get an idea: \n\n\n::: {.cell}\n\n```{.r .cell-code}\nclustree(seu, prefix = \"integrated_snn_res.\")\n```\n\n::: {.cell-output-display}\n![](4_integration_clustering_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-important}\n## Exercise\n\nWhich resolution would you choose for the clusters? If you have made up your mind, set the cluster column to the default identity with `SetIdent`. \n\n::: \n\n::: {.callout-tip collapse=\"true\"}\n## Answer\n\nThere is not 'true' clustering, but based on the `clustree` plot, it seems that after a resolution of 0.5, the clustering stays relatively stable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nres <- \"integrated_snn_res.0.4\"\nseu <- SetIdent(seu, value = res)\n```\n:::\n\n\n:::\n\n::: {.callout-warning}\nThe script below assumes that you have set object `res` to the column of your selected resolution, e.g.:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this is not (necessarily) the correct answer to the previous question!\nres <- \"integrated_snn_res.0.8\"\n```\n:::\n\n::: \n\nNow that we have selected a resolution, we can color both the UMAP and the slices accordingly. First we defnie some appropriate colors, then we plot the UMAP with `DimPlot` and the slices with `SpatialPlot`. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# define a color palette based on the number of clusters\nnclust <- seu[[res]] |> unique() |> nrow()\ncluster_cols <- DiscretePalette(nclust, palette = \"polychrome\")\n\nDimPlot(seu,\n        group.by = res,\n        shuffle = TRUE,\n        cols = cluster_cols)\n```\n\n::: {.cell-output-display}\n![](4_integration_clustering_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\nSpatialPlot(seu, pt.size.factor = 2) + \n  plot_layout(guides='collect') &\n  theme(legend.position = \"none\") &\n  scale_fill_manual(values = cluster_cols)\n```\n\n::: {.cell-output-display}\n![](4_integration_clustering_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\nAfter integration and clustering, we can save the output as an rds files:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsaveRDS(seu,\n        paste0(\"output/seu_part4.rds\"))\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}