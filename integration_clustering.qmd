```{r}
#| output: false
library(Seurat)
library(ggplot2)
library(clustree)
```

```{r}
seu <- readRDS("output/normalized_Posterior.rds")
seu$orig.ident <- "Posterior"
seu2 <- readRDS("output/normalized_Anterior.rds")
seu$orig.ident <- "Anterior"
seu_merge <- merge(seu, seu2)
```

```{r}
VariableFeatures(seu_merge) <- c(VariableFeatures(seu), VariableFeatures(seu2))
seu_merge <- RunPCA(seu_merge, assay = "SCT", npcs = 50, verbose = FALSE)
seu_merge <- RunUMAP(seu_merge, reduction = "pca", dims = 1:50)
```

```{r}
DimPlot(seu_merge, reduction = "pca", group.by = "orig.ident") + NoLegend()
DimPlot(seu_merge, reduction = "umap", group.by = "orig.ident") + 
  ggtitle("") + 
  NoLegend()
```

## Dimensionality reduction 


Selecting which PCs to use: ---------
To overcome the extensive technical noise in any single gene, Seurat clusters spots based on their PCA scores, with each PC essentially representing a metagene that combines information across a correlated group of genes. 

ElbowPlot ranks the principal components based on the variance explained by each. This plot typically shows an "elbow", which can be used to assess how many PCs are needed to capture most of the signal in the data.

```{r}
use.pcs  <- 50
ElbowPlot(seu_merge, ndims = use.pcs)
```

The sctransform workflow performs more effective normalization, strongly removing technical effects from the data,
this means that higher PCs are more likely to represent subtle, but biologically relevant, sources of heterogeneity
- so including them may improve downstream analysis. Therefore, higher number of PC can be used.
By default we are using the first 50 PCs

## Identifying clusters

Seurat implements a graph-based clustering approach. Distances between the spots are calculated based on
previously identified PCs. Briefly, Seurat identifies clusters of spots by a shared nearest neighbor (SNN)
modularity optimization based clustering algorithm. First, it identifies k-nearest neighbors (KNN) and constructs
the SNN graph. Then it optimizes the modularity function to determine clusters. For a full description of the
algorithms, see Waltman and van Eck (2013) The European Physical Journal B.

The FindClusters function implements the procedure, and contains a resolution parameter that sets the granularity
of the downstream clustering, with increased values leading to a greater number of clusters.

```{r}
resolution_vector <- seq(0.2,2,0.2)
seu_merge <- FindNeighbors(seu_merge, reduction = "pca", dims = 1:use.pcs)
seu_merge <- FindClusters(object = seu_merge,
                          resolution = resolution_vector,
                          verbose=FALSE)
```

```{r}
clustree(seu_merge, prefix = "SCT_snn_res.")
```

```{r}
DimPlot(seu_merge, group.by = "SCT_snn_res.1.2")
SpatialDimPlot(seu_merge, group.by = "SCT_snn_res.1.2")
```

```{r}
seu_merge <- IntegrateLayers(
  object = seu_merge,
  method = CCAIntegration,
  normalization.method = "SCT",
  new.reduction = "integrated.cca",
  verbose = TRUE
)

seu_merge[["Spatial"]] <- JoinLayers(seu_merge[["Spatial"]])

DimPlot(seu_merge, group.by = "SCT_snn_res.1.2", reduction = "integrated.cca")
seu_merge <- RunUMAP(seu_merge, dims = 1:30, reduction = "integrated.cca")
DimPlot(seu_merge, group.by = "orig.ident")
```

```{r}
resolution_vector <- seq(0.2,2,0.2)
seu_merge <- FindNeighbors(seu_merge, reduction = "integrated.cca", dims = 1:use.pcs)
seu_merge <- FindClusters(object = seu_merge,
                          resolution = resolution_vector,
                          verbose=FALSE)
```

```{r}
clustree(seu_merge, prefix = "SCT_snn_res.")
```


```{r}
DimPlot(seu_merge, group.by = "SCT_snn_res.0.8")
SpatialDimPlot(seu_merge, group.by = "SCT_snn_res.0.8")
```

```{r}
```

```{r}
seu_merge <-
  FindSpatiallyVariableFeatures(
    seu_merge,
    features = rownames(seu_merge),
    selection.method = "markvariogram"
  )

spatialFeatures <-
  SVFInfo(seu_merge, method = "markvariogram", status = TRUE)
spatialFeatures <- na.omit(spatialFeatures)
spatialFeatures <-
  spatialFeatures %>% filter(variable == TRUE) %>% arrange(rank)
spatialFeatures <- spatialFeatures[, c("r.metric.5"), drop = FALSE]
```

