[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "SIB days tutorial: introduction to spatial transcriptomics",
    "section": "",
    "text": "SIB days tutorial: introduction to spatial transcriptomics\nLorem ipsum"
  },
  {
    "objectID": "2_quality_control.html",
    "href": "2_quality_control.html",
    "title": "Quality control",
    "section": "",
    "text": "In the course_data directories you can find an html report named web_summary.html that gives information about the spaceranger run.\n\n\n\n\n\n\nExercise\n\n\n\nHave a look at both reports. Could we capture the entire slice? Can you expect all spots have reads? How many informative spots do we have for both slices?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nFor both the Anterior and Posterior parts of the slice are outside the captured region\nAlso not all spots are on a slice, the number of spots per slice:\n\nAnterior: 2695\nPosterior: 3355"
  },
  {
    "objectID": "2_quality_control.html#quality-reports",
    "href": "2_quality_control.html#quality-reports",
    "title": "Quality control",
    "section": "",
    "text": "In the course_data directories you can find an html report named web_summary.html that gives information about the spaceranger run.\n\n\n\n\n\n\nExercise\n\n\n\nHave a look at both reports. Could we capture the entire slice? Can you expect all spots have reads? How many informative spots do we have for both slices?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nFor both the Anterior and Posterior parts of the slice are outside the captured region\nAlso not all spots are on a slice, the number of spots per slice:\n\nAnterior: 2695\nPosterior: 3355"
  },
  {
    "objectID": "2_quality_control.html#loading-the-data-into-seurat",
    "href": "2_quality_control.html#loading-the-data-into-seurat",
    "title": "Quality control",
    "section": "Loading the data into Seurat",
    "text": "Loading the data into Seurat\nWe first load the required packages, among which Seurat:\n\nlibrary(Seurat)\nlibrary(tidyr)\nlibrary(patchwork)\nlibrary(ggplot2)\n\nThen we, load the data into two Seurat objects. Here, we loop over the two slices, and combine it in a list of two seurat objects.\n\nseu_list &lt;- lapply(c(\"Anterior\", \"Posterior\"), function(slice) {\n  # load the invidual slices\n  seu &lt;- Load10X_Spatial(data.dir = file.path(\"course_data\", slice),\n                  slice = slice)\n  # set the identity of the spots to the slice identifier\n  seu$orig.ident &lt;- slice\n  return(seu)\n})\n\nAfter creating the list, we merge the two objects into one Seurat object, and we set the default identity (mostly for plotting purposes) to the slice identifier (i.e. Posterior or Anterior).\n\nseu &lt;- merge(seu_list[[1]], seu_list[[2]])\n\nWarning: Some cell names are duplicated across objects provided. Renaming to\nenforce unique cell names.\n\nseu &lt;- SetIdent(seu, value = \"orig.ident\")\n\nThe Seurat object\nThe seu object we have created has the class Seurat. The object contains multi-level slots and lists. Each Seurat object contains exactly the same slots that are specified in the image below (get slot descriptions by typing ?SeuratObject::Seurat). You can get the information inside a slot with @, in the same way as you would use the $ for lists (e.g. seu@meta.data will return the a data frame with information on each cell). Slots can be filled with other R objects, like lists, vectors, data frames or any other class. Here’s an overview of all slots that are in a Seurat object:\n\nIn addition to the original count table and image, the Seurat object can therefore store a lot of information that is generated during your analysis, like results of a normalization (@assays$RNA@data) a PCA or UMAP (@reductions) and the clustering (@graphs). It also tracks all the commands that have been used to generate the object in its current state (@commands). Therefore, while going through the analysis steps, the same object gets more and more of its slots filled. Because most Seurat functions return the input object + adjusted slots, we can use this syntax:\nseurat_object &lt;- Seurat::function(seurat_object)\nSo, the function takes an object as input and we assign it to an object with the same name. Meaning that we overwrite the object used as input. This is fine in many cases, because Seurat adds information to the input object, and returns is.\nIn order to check out the count data that is stored in our Seurat object, we can run GetAssayData, in which we specify the assay and the layer from which we extract the counts. Since we have a combined object we have two layers with counts, counts.1 corresponding to Anterior and counts.2 corresponding to Posterior. Let’s have a look at the counts from the Anterior slice:\n\ncounts &lt;- GetAssayData(seu, assay = \"Spatial\", layer = \"counts.1\")\ncounts[1:10,1:10]\n\n10 x 10 sparse Matrix of class \"dgCMatrix\"\n\n\n  [[ suppressing 10 column names 'AAACAAGTATCTCCCA-1_1', 'AAACACCAATAACTGC-1_1', 'AAACAGAGCGACTCCT-1_1' ... ]]\n\n\n                           \nXkr4    . . . . . . . . . .\nGm1992  . . . . . . . . . .\nGm19938 . . . . . . . . . .\nGm37381 . . . . . . . . . .\nRp1     . . . . . . . . . .\nSox17   . 1 . . . 2 . . 1 .\nGm37587 . . . . . . . . . .\nGm37323 . . . . . . . . . .\nMrpl15  2 1 4 . 2 1 2 3 . 6\nLypla1  . 1 2 2 . . 1 3 1 3\n\n\n\n\n\n\n\n\nExercise\n\n\n\nExtract the matrix with counts belonging the posterior slice and get the median counts per spot by using the function colSums and median on the matrix. Does this correspond with the report?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nWe can get the median counts like this:\n\ncounts &lt;- GetAssayData(seu, assay = \"Spatial\", layer = \"counts.2\")\nmedian_counts &lt;- colSums(counts) |&gt; median()\nmedian_counts\n\n[1] 15783\n\n\nNote that the median counts we have over here, correspond to ‘Median UMI Counts per Spot’ in the report (so not ‘Mean Reads per Spot’). Indeed the also the report shows a median of 15738.\n\n\n\nThe original H&E slice are also part of the Seurat object, and we can visualize those:\n\nSpatialPlot(seu, alpha = 0) + \n  plot_layout(guides='collect') & theme(legend.position = \"none\")\n\n\n\n\n\n\n\nAnd we can plot any feature as an overlay, for example, here we have the number of UMI per spot:\n\nSpatialPlot(seu, features = \"nCount_Spatial\", alpha = 0.5) + \n  plot_layout(guides='collect') & theme(legend.position = \"right\")"
  },
  {
    "objectID": "2_quality_control.html#quality-control",
    "href": "2_quality_control.html#quality-control",
    "title": "Quality control",
    "section": "Quality control",
    "text": "Quality control\nWe can assess the quality of our data at the level of the spots (i.e. the columns in the count matrix) and the genes (the rows). Typically, most quality assessment is done on the level of the spots. Data per spot is stored in the @meta.data slot. This is a data.frame where the rows correspond to the spots, and each column contains data per spot. By loading the data as Seurat object, we have already pre-filled a few meta data columns\n\n\n\n\n\n\nExercise\n\n\n\nCheck out the metadata dataframe by running seu@meta.data. Which columns are already there, and what do they probably mean?\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\nseu@meta.data |&gt; head()\n\n                     orig.ident nCount_Spatial nFeature_Spatial\nAAACAAGTATCTCCCA-1_1   Anterior          13991             4462\nAAACACCAATAACTGC-1_1   Anterior          39797             8126\nAAACAGAGCGACTCCT-1_1   Anterior          29951             6526\nAAACAGCTTTCAGAAG-1_1   Anterior          42333             8190\nAAACAGGGTCTATATT-1_1   Anterior          35700             8090\nAAACATGGTGAGAGGA-1_1   Anterior          22148             6518\n\n\nHere, we have the following information:\n\nrownames: spot barcode (= identifier)\n\norig.ident: the slice identifier\n\nnCount_Spatial: the total number of UMI for each spot\n\nnFeature_Spatial: the total number of detected genes per spot\n\n\n\n\nLibrary size versus detected genes\nWe can use these columns to plot spot metadata. Everytime there is a function in Seurat that contains an option feature we can fill it out, like in FeatureScatter, that we can use to plot the number of genes versus the number of UMI.\n\nFeatureScatter(seu,\n               feature1 = \"nCount_Spatial\",\n               feature2 = \"nFeature_Spatial\",\n               shuffle = TRUE\n) + scale_color_viridis_d(option = \"cividis\")\n\n\n\n\n\n\n\nPercent of mitochondrial UMI\nA high percentage of mitochondrial UMI can point to low quality spots, because damaged cells typically leak out cytoplasmic mRNA, while the mitochondria stay inside. We can calculate the percentage of mitochondria like this:\n\nseu &lt;- PercentageFeatureSet(seu,\n                             pattern = \"^MT-|^Mt-|^mt-\",\n                             col.name = \"percent_mt\"\n)\n\n\n\n\n\n\n\nExercise\n\n\n\nThe percentage of mitochondrial UMI is stored in the @meta.data slot. What is the name of the column?\nPlot the percentage of mitochondrial UMI versus the number of UMI per spot with FeatureScatter.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nA column names percent_mt appeared.\n\nhead(seu@meta.data)\n\n                     orig.ident nCount_Spatial nFeature_Spatial percent_mt\nAAACAAGTATCTCCCA-1_1   Anterior          13991             4462  10.871274\nAAACACCAATAACTGC-1_1   Anterior          39797             8126   9.993216\nAAACAGAGCGACTCCT-1_1   Anterior          29951             6526  14.239925\nAAACAGCTTTCAGAAG-1_1   Anterior          42333             8190   6.779581\nAAACAGGGTCTATATT-1_1   Anterior          35700             8090   5.128852\nAAACATGGTGAGAGGA-1_1   Anterior          22148             6518  10.791042\n\n\nWe can create the scatterplot like this:\n\nFeatureScatter(seu,\n               feature1 = \"nCount_Spatial\",\n               feature2 = \"percent_mt\",\n               shuffle = TRUE\n) + scale_color_viridis_d(option = \"cividis\")\n\n\n\n\n\n\n\n\n\n\nNow we have to decide whether we want to filter away spots with high mitochondrial counts, and if so, at what threshold. In order to make a decision, it makes sense to plot the mitochondrial counts in a spatial context, so we can check whether it correpsonds to spatial features:\n\nSpatialPlot(seu, features = \"percent_mt\", alpha = 0.7) + \n  plot_layout(guides='collect') & theme(legend.position = \"right\")\n\n\n\n\n\n\n\nWe can see that a high percentage of mitochondrial counts correspond with the hippocampus, and the sides of the out areas of the cortex. In the posterior slice, there is a clear spatial context and there is no clear indication for spots being damaged, we will not filter out spots based on mitochondrial UMI. However, in the Anterior slice, we see a spot outside the main area (just above the olfactory bulb) that seems to have ended up there because of debris."
  },
  {
    "objectID": "2_quality_control.html#filtering",
    "href": "2_quality_control.html#filtering",
    "title": "Quality control",
    "section": "Filtering",
    "text": "Filtering\nIdentifying low-quality spots\nWe decide to filter out the spot that is high in UMI counts in the Anterior slice and in addition, we will filter spots that have fewer than 500 genes expressed. In order to visualize the spots we create two more columns in the @meta.data slot that represent which cell are filtered out. s\n\n# defining the high mt spot in anterior\nseu$percent_mt_keep &lt;- !(seu$orig.ident == \"Anterior\" & seu$percent_mt &gt; 38)\n\nSpatialPlot(seu, group.by = \"percent_mt_keep\") +\n  plot_annotation(title = \"Filter % mitochondrial UMI\") +\n  plot_layout(guides='collect') & theme(legend.position = \"none\") \n\n\n\n\n\n\n# defining the low number of genes\nseu$nFeature_Spatial_keep &lt;- seu$nFeature_Spatial &gt; 100\n\nSpatialPlot(seu, group.by = \"nFeature_Spatial_keep\") +\n  plot_annotation(title = \"Filter % low number of features\") +\n  plot_layout(guides='collect') & theme(legend.position = \"none\")\n\n\n\n\n\n\n\nNow, we remove the spots, and visualize the spots that are left over:\n\nseu &lt;- seu[, seu$percent_mt_keep & seu$nFeature_Spatial_keep]\n\nWarning: Not validating Centroids objects\nNot validating Centroids objects\n\n\nWarning: Not validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\n\n\nWarning: Not validating Seurat objects\n\n\nWarning: Not validating Centroids objects\nNot validating Centroids objects\n\n\nWarning: Not validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\n\n\nWarning: Not validating Seurat objects\n\nSpatialPlot(seu, alpha = 0.5, group.by = \"percent_mt_keep\")  +\n  plot_layout(guides='collect') & theme(legend.position = \"none\")\n\n\n\n\n\n\n\nGene-level QC\nSome genes can be expressed in very high percentages and therefore have a large effect on the normalization. In order to see whether there are genes that are very high expressed we can plot them by percentage of the total counts per spot:\n\nmost_expressed_boxplot &lt;- function(raw_counts) {\n  raw_counts@x &lt;-\n    raw_counts@x / rep.int(colSums(raw_counts), diff(raw_counts@p)) * 100\n  most_expressed &lt;-\n    order(Matrix::rowSums(raw_counts), decreasing = TRUE)[30:1]\n  \n  raw_counts[most_expressed,] |&gt;\n    as.matrix() |&gt;\n    t() |&gt;\n    boxplot(\n      cex.axis = 0.5,\n      cex.lab = 0.8,\n      cex = 0.1,\n      las = 1,\n      xlab = \"% total count per spot\",\n      col = (scales::hue_pal())(30)[30:1],\n      horizontal = TRUE\n    )\n}\n\n\nmost_expressed_boxplot(seu[[\"Spatial\"]]$counts.1)\n\n\n\n\n\n\nmost_expressed_boxplot(seu[[\"Spatial\"]]$counts.2)\n\n\n\n\n\n\n\nAs we don’t see very high expression percentages, and it happens for expected genes (e.g. Bc1), we decide to keep all genes in the analysis."
  },
  {
    "objectID": "2_quality_control.html#normalization",
    "href": "2_quality_control.html#normalization",
    "title": "Quality control",
    "section": "Normalization",
    "text": "Normalization\nBiological heterogeneity in spatial RNA-seq data is often confounded by technical factors including sequencing depth. The number of molecules detected in each spot can vary significantly between spots, even within the same celltype. Note that the variance in molecular counts/spot can be substantial for spatial datasets, particularly if there are differences in cell density across the tissue.\nTherefore, we apply sctransform normalization (Hafemeister and Satija, Genome Biology 2019), which builds regularized negative binomial models of gene expression in order to account for technical artifacts while preserving biological variance. During the normalization, we also remove confounding sources of variation (here we take mitochondrial mapping percentage).\nWe need to apply SCTransform on each individual slice. Therefore, we split the object back into a list (with SplitObject). Next, we run into a small issue that both slice images are maintained in the split object, so we have keep only the image corresponding to the count table. Then, we apply SCTransform on the individual slices and merge the objects back together with merge:\n\nseu_list &lt;- SplitObject(seu, split.by = \"orig.ident\")\n\nWarning: Not validating Centroids objects\nNot validating Centroids objects\n\n\nWarning: Not validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\n\n\nWarning: Not validating Seurat objects\nNot validating Seurat objects\nNot validating Seurat objects\n\n\nWarning: Not validating Centroids objects\nNot validating Centroids objects\n\n\nWarning: Not validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\nNot validating FOV objects\n\n\nWarning: Not validating Seurat objects\n\n# images aren't split with SplitObject. Resetting the images. \nfor(slice in names(seu_list)) {\n  seu_list[[slice]]@images &lt;- setNames(\n    list(seu_list[[slice]]@images[[slice]]),\n    slice)\n  \n  # bugfix based on https://github.com/satijalab/seurat/issues/8216\n  seu_list[[slice]][[\"RNA\"]] &lt;- seu_list[[slice]][[\"Spatial\"]]\n  DefaultAssay(seu_list[[slice]]) &lt;- \"RNA\"\n}\n\nWarning: Key 'spatial_' taken, using 'rna_' instead\n\n\nWarning: Key 'spatial_' taken, using 'rna_' instead\n\nseu_list &lt;- lapply(X = seu_list, FUN = SCTransform, assay = \"RNA\",\n                   vars.to.regress = \"percent_mt\")\n\nWarning: replacing previous import 'S4Arrays::makeNindexFromArrayViewport' by\n'DelayedArray::makeNindexFromArrayViewport' when loading 'SummarizedExperiment'\n\n\n\n\n\n\n\n\nExercise\n\n\n\nAfter running the code, to do the SCT transformation, which assays have been added to the seurat object? Note that you can get assay data with the function Assays.\n\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\nJust by typing the object name (seu) we see which layers are in there:\n\nAssays(seu_list[[1]])\n\n[1] \"Spatial\" \"RNA\"     \"SCT\"    \n\n\nShowing us that an assay called SCT has appeared.\n\n\n\nNow that we have done the transformation it is also possible to plot gene experssion information in a spatial context, e.g. Ttr:\n\nSpatialPlot(seu_list$Anterior, features = \"Ttr\") + \n  SpatialPlot(seu_list$Posterior, features = \"Ttr\") + \n  plot_layout(guides='collect') & theme(legend.position = \"right\")\n\n\n\n\n\n\n\nAfter quality control and transformation, we can save the output as an rds files:\n\noutput_folder &lt;- \"output\"\ndir.create(output_folder, showWarnings = FALSE)\n\nsaveRDS(seu_list,\n        paste0(\"output/normalized.rds\"))"
  },
  {
    "objectID": "1_setup.html#exercises",
    "href": "1_setup.html#exercises",
    "title": "Setup",
    "section": "Exercises",
    "text": "Exercises\nLogin and set up\nLog in to Rstudio server with the provided link, username and password.\nCreate a project\nNow that you have access to an environment with the required installations, we will set up a project in a new directory. On the top right choose the button Project (None) and select New Project…\n\nContinue by choosing New Directory\n\nAs project type select New Project\n\nFinally, type in the project name. This should be spatial_transcriptomics_course. Finish by clicking Create Project.\n\nNow that we have setup a project and a project directory (it is in /home/rstudio/spatial_transcriptomics_course), we can download the data that is required for this course. We will use the built-in terminal of Rstudio. To do this, select the Terminal tab:\n\nDownloading the course data\nTo download and extract the dataset, copy-paste these commands inside the terminal tab:\n\nmkdir -p course_data/Anterior\nmkdir -p course_data/Posterior\n\n# Anterior\ncd course_data/Anterior\n\nLINK_PREFIX=https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Mouse_Brain_Sagittal_Anterior/V1_Mouse_Brain_Sagittal_Anterior\n\ncurl -o filtered_feature_bc_matrix.h5 \"$LINK_PREFIX\"_filtered_feature_bc_matrix.h5\ncurl -o spatial.tar.gz \"$LINK_PREFIX\"_spatial.tar.gz\ncurl -o web_summary.html \"$LINK_PREFIX\"_web_summary.html\ntar -xf spatial.tar.gz\nrm spatial.tar.gz\n\n# Posterior\ncd ../Posterior\n\nLINK_PREFIX=https://cf.10xgenomics.com/samples/spatial-exp/1.1.0/V1_Mouse_Brain_Sagittal_Posterior/V1_Mouse_Brain_Sagittal_Posterior\ncurl -o filtered_feature_bc_matrix.h5 \"$LINK_PREFIX\"_filtered_feature_bc_matrix.h5\ncurl -o spatial.tar.gz \"$LINK_PREFIX\"_spatial.tar.gz\ncurl -o web_summary.html \"$LINK_PREFIX\"_web_summary.html\n\ntar -xf spatial.tar.gz\nrm spatial.tar.gz\n\nHave a look at the data directory you have downloaded. It should contain the following:\ncourse_data/\n├── Anterior\n│   ├── filtered_feature_bc_matrix.h5\n│   ├── spatial\n│   │   ├── aligned_fiducials.jpg\n│   │   ├── detected_tissue_image.jpg\n│   │   ├── scalefactors_json.json\n│   │   ├── tissue_hires_image.png\n│   │   ├── tissue_lowres_image.png\n│   │   └── tissue_positions_list.csv\n│   └── web_summary.html\n└── Posterior\n    ├── filtered_feature_bc_matrix.h5\n    ├── spatial\n    │   ├── aligned_fiducials.jpg\n    │   ├── detected_tissue_image.jpg\n    │   ├── scalefactors_json.json\n    │   ├── tissue_hires_image.png\n    │   ├── tissue_lowres_image.png\n    │   └── tissue_positions_list.csv\n    └── web_summary.html\n\n4 directories, 16 files\nIn this tutorial we are working with two mouse brain slices, the anterior and posterior. The two brain sections represent the sagittal (longitudinal) plane of the mouse brain:\n\n\nMouse brain sagittal\n\nYou can find an interactive map with all brain regions at the Allen Brain Atlas\nOur slices contain the anterior and posterior sides of the sagittal section of the mouse brain:\n\n\n\n\n\n\n\n\nAnterior\n\n\n\n\n\nPosterior\n\n\n\n\nThis data is provided by 10x genomics, and further information, like material and methods can be found here:\n\nAntherior: https://www.10xgenomics.com/datasets/mouse-brain-serial-section-1-sagittal-anterior-1-standard-1-1-0\n\nPosterior: https://www.10xgenomics.com/datasets/mouse-brain-serial-section-1-sagittal-posterior-1-standard-1-1-0"
  },
  {
    "objectID": "3_integration_clustering.html",
    "href": "3_integration_clustering.html",
    "title": "Integration and clustering",
    "section": "",
    "text": "library(Seurat)\nlibrary(ggplot2)\nlibrary(clustree)\nlibrary(patchwork)\nlibrary(dplyr)\nseu_list &lt;- readRDS(\"output/normalized.rds\")\nseu &lt;- merge(seu_list[[1]], seu_list[[2]])\nVariableFeatures(seu) &lt;- intersect(VariableFeatures(seu_list$Anterior),\n                           VariableFeatures(seu_list$Posterior))\nseu &lt;- RunPCA(seu, assay = \"SCT\", npcs = 50, verbose = FALSE)\nseu &lt;- RunUMAP(seu, reduction = \"pca\", dims = 1:50)\nDimPlot(seu, reduction = \"pca\", group.by = \"orig.ident\") + \n  scale_color_viridis_d(option = \"cividis\")\n\n\n\n\n\n\nDimPlot(seu, reduction = \"umap\", group.by = \"orig.ident\") + \n  scale_color_viridis_d(option = \"cividis\")"
  },
  {
    "objectID": "3_integration_clustering.html#integration",
    "href": "3_integration_clustering.html#integration",
    "title": "Integration and clustering",
    "section": "Integration",
    "text": "Integration\nYou can safely ignore the warning: Warning: Different cells and/or features from existing assay SCT. See this issue.\n\nfeatures &lt;- SelectIntegrationFeatures(seu_list)\nseu_list &lt;- PrepSCTIntegration(seu_list, anchor.features = features)\n\nanchors &lt;- FindIntegrationAnchors(\n  seu_list,\n  normalization.method = \"SCT\",\n  anchor.features = features\n)\nseu_int &lt;- IntegrateData(anchors, normalization.method = \"SCT\")\n\n\nseu_int &lt;- FindVariableFeatures(seu_int)\nseu_int &lt;- RunPCA(seu_int, npcs = 50, verbose = FALSE)\nseu_int &lt;- RunUMAP(seu_int, reduction = \"pca\", dims = 1:50)\nDimPlot(seu_int, reduction = \"umap\") + \n  scale_color_viridis_d(option = \"cividis\")"
  },
  {
    "objectID": "3_integration_clustering.html#identifying-clusters",
    "href": "3_integration_clustering.html#identifying-clusters",
    "title": "Integration and clustering",
    "section": "Identifying clusters",
    "text": "Identifying clusters\nSeurat implements a graph-based clustering approach. Distances between the spots are calculated based on previously identified PCs. Briefly, Seurat identifies clusters of spots by a shared nearest neighbor (SNN) modularity optimization based clustering algorithm. First, it identifies k-nearest neighbors (KNN) and constructs the SNN graph. Then it optimizes the modularity function to determine clusters. For a full description of the algorithms, see Waltman and van Eck (2013) The European Physical Journal B.\nThe FindClusters function implements the procedure, and contains a resolution parameter that sets the granularity of the downstream clustering, with increased values leading to a greater number of clusters.\n\nresolution_vector &lt;- seq(0.1,1,0.1)\nseu_int &lt;- FindNeighbors(seu_int, reduction = \"pca\", dims = 1:50)\n\nComputing nearest neighbor graph\n\n\nComputing SNN\n\nseu_int &lt;- FindClusters(object = seu_int,\n                          resolution = resolution_vector,\n                          verbose=FALSE)\n\n\nclustree(seu_int, prefix = \"integrated_snn_res.\")\n\n\n\n\n\n\n\n\nres &lt;- \"integrated_snn_res.0.4\"\nnclust &lt;- seu_int[[res]] |&gt; unique() |&gt; nrow()\ncluster_cols &lt;- viridis::viridis_pal(option = \"H\")(nclust)\n\nDimPlot(seu_int,\n        group.by = res,\n        shuffle = TRUE,\n        cols = cluster_cols)\n\n\n\n\n\n\nSpatialPlot(seu_int, group.by = res, pt.size.factor = 2) + \n  plot_layout(guides='collect') &\n  theme(legend.position = \"none\") &\n  scale_fill_viridis_d(option = \"H\")\n\n\n\n\n\n\n\n\nIdents(seu_int) &lt;- \"integrated_snn_res.0.4\"\n\nSpatialDimPlot(seu_int, \n               alpha = 0.6,\n               cells.highlight = CellsByIdentities(object = seu_int,\n                                                   idents = 7)) + \n  plot_layout(guides='collect') &\n  theme(legend.position = \"none\") \n\n\n\n\n\n\nSpatialDimPlot(seu_int, \n               alpha = 0.6,\n               cells.highlight = CellsByIdentities(object = seu_int,\n                                                   idents = 4)) + \n  plot_layout(guides='collect') &\n  theme(legend.position = \"none\") \n\n\n\n\n\n\nSpatialDimPlot(seu_int, \n               alpha = 0.6,\n               cells.highlight = CellsByIdentities(object = seu_int,\n                                                   idents = 0)) + \n  plot_layout(guides='collect') &\n  theme(legend.position = \"none\") \n\n\n\n\n\n\n\n\nseu_int &lt;- PrepSCTFindMarkers(seu_int)\nall_marks &lt;- FindAllMarkers(seu_int, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)\n\n\nSpatialPlot(seu_int, features = \"Fth1\") \n\n\n\n\n\n\n# oligodendrocytes, myenilated neurons\n\n\ntop_specific_markers &lt;- all_marks |&gt;\n  group_by(cluster) |&gt;\n  top_n(3, avg_log2FC)\n\nDotPlot(seu_int, features = top_specific_markers$gene) +\n  scale_x_discrete(guide = guide_axis(angle = 45))\n\n\n\n\n\n\n\n\nDefaultAssay(seu_list$Anterior) &lt;- \"SCT\"\n\nseu_list$Anterior &lt;-\n  FindSpatiallyVariableFeatures(\n    seu_list$Anterior,\n    features = rownames(seu_int),\n    selection.method = \"moransi\"\n  )\n\nComputing Moran's I\n\n\nWarning in dist(x = pos): NAs introduced by coercion\n\nspatialFeatures &lt;-\n  SVFInfo(seu_list$Anterior, method = \"moransi\", status = TRUE)\nspatialFeatures &lt;-\n  spatialFeatures |&gt; arrange(rank)\n\nSpatialPlot(seu_list$Anterior, features = rownames(spatialFeatures)[1:6], ncol = 3, alpha = c(0.1, 1))"
  }
]